{"version":3,"file":"2556.252af8abee93d052.js","mappings":"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","names":["concat","_len","arguments","length","args","Array","_key","concatAll","mergeAll","from","popScheduler","defer","observableFactory","Observable","subscriber","innerFrom","subscribe","EMPTY","complete","subscribeOn","scheduler","delay","undefined","operate","source","add","schedule","scheduleAsyncIterable","input","Error","executeSchedule","iterator","Symbol","asyncIterator","next","then","result","done","value","scheduled","isInteropObservable","scheduleObservable","pipe","observeOn","isArrayLike","scheduleArray","i","closed","this","isPromise","schedulePromise","isAsyncIterable","isIterable","scheduleIterable","Symbol_iterator","_iterator$next","err","error","isFunction","return","isReadableStreamLike","scheduleReadableStreamLike","readableStreamLikeToAsyncGenerator","createInvalidObservableTypeError","nodeEventEmitterMethods","eventTargetMethods","jqueryMethods","fromEvent","target","eventName","options","resultSelector","mapOneOrManyArgs","_ref","isEventTarget","addEventListener","removeEventListener","map","methodName","handler","isNodeStyleEventEmitter","addListener","removeListener","toCommonHandlerRegistry","isJQueryStyleEventEmitter","on","off","_ref2","_slicedToArray","remove","mergeMap","subTarget","TypeError","merge","concurrent","popNumber","Infinity","sources","of","createOperatorSubscriber","destination","onNext","onComplete","onError","onFinalize","OperatorSubscriber","_Subscriber","_inherits","_super","_createSuper","shouldUnsubscribe","_thisSuper","_thisSuper2","_thisSuper3","_this","_classCallCheck","call","_next","_get","_assertThisInitialized","_getPrototypeOf","prototype","_error","unsubscribe","_complete","_createClass","key","_a","Subscriber","delayWhen","delayDurationSelector","subscriptionDelay","take","ignoreElements","index","mapTo","due","duration","timer","asyncScheduler","filter","predicate","thisArg","noop","identity","startWith","values","switchMap","project","innerSubscriber","isComplete","checkComplete","innerIndex","outerIndex","innerValue","count","seen","tap","observerOrNext","tapObserver","isUnsub","_b","finalize","last","arr","popResultSelector","pop","isScheduler","defaultValue","hasLift","lift","init","liftedSource","isArray","fn","callOrApply","apply","_toConsumableArray","_c0","MatAutocomplete_ng_template_0_Template","rf","ctx","i0","formFieldId_r1","id","ctx_r0","_classList","isOpen","ariaLabel","_getPanelAriaLabelledby","_c1","panelAnimation","trigger","state","style","opacity","transform","transition","group","animate","_uniqueAutocompleteIdCounter","MatAutocompleteSelectedEvent","option","_MatAutocompleteMixinBase","mixinDisableRipple","_class","MAT_AUTOCOMPLETE_DEFAULT_OPTIONS","InjectionToken","providedIn","factory","MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY","autoActiveFirstOption","autoSelectActiveOption","hideSingleSelectionIndicator","_MatAutocompleteBase","_MatAutocompleteMixin","_changeDetectorRef","_elementRef","_defaults","platform","_activeOptionChanges","Subscription","showPanel","_isOpen","displayWith","optionSelected","EventEmitter","opened","optionActivated","inertGroups","SAFARI","_autoActiveFirstOption","_autoSelectActiveOption","get","_color","_setThemeClasses","set","coerceBooleanProperty","coerceStringArray","reduce","classList","className","_setVisibilityClasses","nativeElement","_this2","_keyManager","ActiveDescendantKeyManager","withWrap","skipPredicate","_skipPredicate","change","emit","toArray","_setVisibility","_this$_keyManager","destroy","scrollTop","panel","markForCheck","event","labelId","ariaLabelledby","_visibleClass","_hiddenClass","disabled","ɵfac","t","i1","ɵdir","type","viewQuery","_t","TemplateRef","template","first","inputs","panelWidth","outputs","features","MatAutocomplete","_MatAutocompleteBase2","_super2","_this3$_defaults$hide","_this3","_hideSingleSelectionIndicator","_syncParentProperties","_step","_iterator","_createForOfIteratorHelper","s","n","e","f","_option","ɵMatAutocomplete_BaseFactory","ɵcmp","selectors","contentQueries","dirIndex","MAT_OPTGROUP","MatOption","optionGroups","hostAttrs","disableRipple","exportAs","provide","MAT_OPTION_PARENT_COMPONENT","useExisting","ngContentSelectors","decls","vars","consts","dependencies","i2","styles","encapsulation","data","animation","changeDetection","_MatAutocompleteOriginBase","elementRef","MatAutocompleteOrigin","_MatAutocompleteOrigi","_super3","ɵMatAutocompleteOrigin_BaseFactory","MAT_AUTOCOMPLETE_VALUE_ACCESSOR","NG_VALUE_ACCESSOR","forwardRef","MatAutocompleteTrigger","multi","getMatAutocompleteMissingPanelError","MAT_AUTOCOMPLETE_SCROLL_STRATEGY","MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY","overlay","scrollStrategies","reposition","MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER","deps","Overlay","useFactory","_MatAutocompleteTriggerBase","_element","_overlay","_viewContainerRef","_zone","scrollStrategy","_dir","_formField","_document","_viewportRuler","_this4","_componentDestroyed","_autocompleteDisabled","_manuallyFloatingLabel","_viewportSubscription","_canOpenOnNextFocus","_closeKeyEventStream","Subject","_windowBlurHandler","activeElement","panelOpen","_onChange","_onTouched","position","autocompleteAttribute","_overlayAttached","optionSelections","autocomplete","changes","onSelectionChange","onStable","_scrollStrategy","_this5","window","_getWindow","runOutsideAngular","_positionStrategy","_setStrategyPositions","_overlayRef","updatePosition","_destroyPanel","_attachOverlay","_floatLabel","_this6","_resetLabel","run","_pendingAutoselectedOption","hasAttached","detach","_closingActionsSubscription","detectChanges","_this7","tabOut","_getOutsideClickStream","detachments","MatOptionSelectionChange","activeItem","_this8","clickTarget","_getEventTarget","formField","customOrigin","connectedTo","contains","overlayElement","_this9","Promise","resolve","_assignOptionValue","isDisabled","keyCode","hasModifier","hasModifierKey","ESCAPE","preventDefault","activeOption","ENTER","_selectViaInteraction","_resetActiveItem","prevActiveItem","isArrowKey","UP_ARROW","DOWN_ARROW","TAB","onKeydown","_canOpen","openPanel","_scrollToOption","activeItemIndex","_valueBeforeAutoSelection","parseFloat","_previousValue","floatLabel","_animateAndLockLabel","_this10","firstStable","optionChanges","reapplyLastPosition","wasOpen","panelClosingActions","_setValueAndClose","closePanel","dispose","toDisplay","_updateNativeInputValue","_control","toSelect","_clearPreviousSelectedOption","_emitSelectEvent","focus","skip","forEach","selected","deselect","_this$_formField2","_this$_formField","_this11","overlayRef","setOrigin","_getConnectedElement","updateSize","width","_getPanelWidth","_portal","TemplatePortal","getLabelId","create","_getOverlayConfig","_handleOverlayEvents","attach","_subscribeToClosingActions","_setColor","color","_this$_dir","_this$_defaults","OverlayConfig","positionStrategy","_getOverlayPosition","direction","panelClass","overlayPanelClass","strategy","flexibleConnectedTo","withFlexibleDimensions","withPush","positions","belowPositions","originX","originY","overlayX","overlayY","_aboveClass","abovePositions","withPositions","getConnectedOverlayOrigin","_getHostWidth","getBoundingClientRect","firstEnabledOptionIndex","setActiveItem","element","readOnly","_this$_document","defaultView","labelCount","_countGroupLabelsBeforeOption","_setScrollTop","_getHostElement","newScrollPosition","_getOptionScrollPosition","offsetTop","offsetHeight","_getScrollTop","_this12","keydownEvents","_this12$_valueBeforeA","stopPropagation","outsidePointerEvents","i1$1","i2$1","MAT_FORM_FIELD","DOCUMENT","i3","autocompleteDisabled","_MatAutocompleteTrigg","_super4","_this13","ɵMatAutocompleteTrigger_BaseFactory","hostVars","hostBindings","_handleFocus","$event","_handleInput","_handleKeydown","_handleClick","toString","MatAutocompleteModule","ɵmod","ɵinj","providers","imports","OverlayModule","MatOptionModule","MatCommonModule","CommonModule","CdkScrollableModule","_arrayLikeToArray","len","arr2","o","allowArrayLike","it","_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_0__","Z","F","_e","normalCompletion","didErr","step","_e2","Reflect","bind","property","receiver","base","_superPropBase","object","Object","hasOwnProperty","getPrototypeOf","desc","getOwnPropertyDescriptor","_iterableToArray","iter","_arrayWithoutHoles","arrayLikeToArray","iterableToArray","unsupportedIterableToArray","_nonIterableSpread","_unsupportedIterableToArray","minLen","_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__","slice","constructor","name","test"],"sourceRoot":"webpack:///","sources":["./node_modules/rxjs/dist/esm/internal/observable/concat.js","./node_modules/rxjs/dist/esm/internal/operators/concatAll.js","./node_modules/rxjs/dist/esm/internal/observable/defer.js","./node_modules/rxjs/dist/esm/internal/observable/empty.js","./node_modules/rxjs/dist/esm/internal/operators/subscribeOn.js","./node_modules/rxjs/dist/esm/internal/scheduled/scheduleAsyncIterable.js","./node_modules/rxjs/dist/esm/internal/observable/from.js","./node_modules/rxjs/dist/esm/internal/scheduled/scheduled.js","./node_modules/rxjs/dist/esm/internal/scheduled/scheduleObservable.js","./node_modules/rxjs/dist/esm/internal/scheduled/scheduleArray.js","./node_modules/rxjs/dist/esm/internal/scheduled/schedulePromise.js","./node_modules/rxjs/dist/esm/internal/scheduled/scheduleIterable.js","./node_modules/rxjs/dist/esm/internal/scheduled/scheduleReadableStreamLike.js","./node_modules/rxjs/dist/esm/internal/observable/fromEvent.js","./node_modules/rxjs/dist/esm/internal/observable/merge.js","./node_modules/rxjs/dist/esm/internal/observable/of.js","./node_modules/rxjs/dist/esm/internal/operators/OperatorSubscriber.js","./node_modules/rxjs/dist/esm/internal/operators/delayWhen.js","./node_modules/rxjs/dist/esm/internal/operators/delay.js","./node_modules/rxjs/dist/esm/internal/operators/filter.js","./node_modules/rxjs/dist/esm/internal/operators/ignoreElements.js","./node_modules/rxjs/dist/esm/internal/operators/mapTo.js","./node_modules/rxjs/dist/esm/internal/operators/mergeAll.js","./node_modules/rxjs/dist/esm/internal/operators/observeOn.js","./node_modules/rxjs/dist/esm/internal/operators/startWith.js","./node_modules/rxjs/dist/esm/internal/operators/switchMap.js","./node_modules/rxjs/dist/esm/internal/operators/take.js","./node_modules/rxjs/dist/esm/internal/operators/tap.js","./node_modules/rxjs/dist/esm/internal/util/args.js","./node_modules/rxjs/dist/esm/internal/util/lift.js","./node_modules/rxjs/dist/esm/internal/util/mapOneOrManyArgs.js","./node_modules/@angular/material/fesm2022/autocomplete.mjs","./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","./node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","./node_modules/@babel/runtime/helpers/esm/get.js","./node_modules/@babel/runtime/helpers/esm/superPropBase.js","./node_modules/@babel/runtime/helpers/esm/iterableToArray.js","./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"],"sourcesContent":["import { concatAll } from '../operators/concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\nexport function concat(...args) {\n    return concatAll()(from(args, popScheduler(args)));\n}\n","import { mergeAll } from './mergeAll';\nexport function concatAll() {\n    return mergeAll(1);\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from './innerFrom';\nexport function defer(observableFactory) {\n    return new Observable((subscriber) => {\n        innerFrom(observableFactory()).subscribe(subscriber);\n    });\n}\n","import { Observable } from '../Observable';\nexport const EMPTY = new Observable((subscriber) => subscriber.complete());\nexport function empty(scheduler) {\n    return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\nfunction emptyScheduled(scheduler) {\n    return new Observable((subscriber) => scheduler.schedule(() => subscriber.complete()));\n}\n","import { operate } from '../util/lift';\nexport function subscribeOn(scheduler, delay = 0) {\n    return operate((source, subscriber) => {\n        subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));\n    });\n}\n","import { Observable } from '../Observable';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function scheduleAsyncIterable(input, scheduler) {\n    if (!input) {\n        throw new Error('Iterable cannot be null');\n    }\n    return new Observable((subscriber) => {\n        executeSchedule(subscriber, scheduler, () => {\n            const iterator = input[Symbol.asyncIterator]();\n            executeSchedule(subscriber, scheduler, () => {\n                iterator.next().then((result) => {\n                    if (result.done) {\n                        subscriber.complete();\n                    }\n                    else {\n                        subscriber.next(result.value);\n                    }\n                });\n            }, 0, true);\n        });\n    });\n}\n","import { scheduled } from '../scheduled/scheduled';\nimport { innerFrom } from './innerFrom';\nexport function from(input, scheduler) {\n    return scheduler ? scheduled(input, scheduler) : innerFrom(input);\n}\n","import { scheduleObservable } from './scheduleObservable';\nimport { schedulePromise } from './schedulePromise';\nimport { scheduleArray } from './scheduleArray';\nimport { scheduleIterable } from './scheduleIterable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isPromise } from '../util/isPromise';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isIterable } from '../util/isIterable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isReadableStreamLike } from '../util/isReadableStreamLike';\nimport { scheduleReadableStreamLike } from './scheduleReadableStreamLike';\nexport function scheduled(input, scheduler) {\n    if (input != null) {\n        if (isInteropObservable(input)) {\n            return scheduleObservable(input, scheduler);\n        }\n        if (isArrayLike(input)) {\n            return scheduleArray(input, scheduler);\n        }\n        if (isPromise(input)) {\n            return schedulePromise(input, scheduler);\n        }\n        if (isAsyncIterable(input)) {\n            return scheduleAsyncIterable(input, scheduler);\n        }\n        if (isIterable(input)) {\n            return scheduleIterable(input, scheduler);\n        }\n        if (isReadableStreamLike(input)) {\n            return scheduleReadableStreamLike(input, scheduler);\n        }\n    }\n    throw createInvalidObservableTypeError(input);\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nexport function scheduleObservable(input, scheduler) {\n    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n","import { Observable } from '../Observable';\nexport function scheduleArray(input, scheduler) {\n    return new Observable((subscriber) => {\n        let i = 0;\n        return scheduler.schedule(function () {\n            if (i === input.length) {\n                subscriber.complete();\n            }\n            else {\n                subscriber.next(input[i++]);\n                if (!subscriber.closed) {\n                    this.schedule();\n                }\n            }\n        });\n    });\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nexport function schedulePromise(input, scheduler) {\n    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n","import { Observable } from '../Observable';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from '../util/isFunction';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function scheduleIterable(input, scheduler) {\n    return new Observable((subscriber) => {\n        let iterator;\n        executeSchedule(subscriber, scheduler, () => {\n            iterator = input[Symbol_iterator]();\n            executeSchedule(subscriber, scheduler, () => {\n                let value;\n                let done;\n                try {\n                    ({ value, done } = iterator.next());\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return;\n                }\n                if (done) {\n                    subscriber.complete();\n                }\n                else {\n                    subscriber.next(value);\n                }\n            }, 0, true);\n        });\n        return () => isFunction(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return();\n    });\n}\n","import { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nexport function scheduleReadableStreamLike(input, scheduler) {\n    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { Observable } from '../Observable';\nimport { mergeMap } from '../operators/mergeMap';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isFunction } from '../util/isFunction';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nconst nodeEventEmitterMethods = ['addListener', 'removeListener'];\nconst eventTargetMethods = ['addEventListener', 'removeEventListener'];\nconst jqueryMethods = ['on', 'off'];\nexport function fromEvent(target, eventName, options, resultSelector) {\n    if (isFunction(options)) {\n        resultSelector = options;\n        options = undefined;\n    }\n    if (resultSelector) {\n        return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));\n    }\n    const [add, remove] = isEventTarget(target)\n        ? eventTargetMethods.map((methodName) => (handler) => target[methodName](eventName, handler, options))\n        :\n            isNodeStyleEventEmitter(target)\n                ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))\n                : isJQueryStyleEventEmitter(target)\n                    ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))\n                    : [];\n    if (!add) {\n        if (isArrayLike(target)) {\n            return mergeMap((subTarget) => fromEvent(subTarget, eventName, options))(innerFrom(target));\n        }\n    }\n    if (!add) {\n        throw new TypeError('Invalid event target');\n    }\n    return new Observable((subscriber) => {\n        const handler = (...args) => subscriber.next(1 < args.length ? args : args[0]);\n        add(handler);\n        return () => remove(handler);\n    });\n}\nfunction toCommonHandlerRegistry(target, eventName) {\n    return (methodName) => (handler) => target[methodName](eventName, handler);\n}\nfunction isNodeStyleEventEmitter(target) {\n    return isFunction(target.addListener) && isFunction(target.removeListener);\n}\nfunction isJQueryStyleEventEmitter(target) {\n    return isFunction(target.on) && isFunction(target.off);\n}\nfunction isEventTarget(target) {\n    return isFunction(target.addEventListener) && isFunction(target.removeEventListener);\n}\n","import { mergeAll } from '../operators/mergeAll';\nimport { innerFrom } from './innerFrom';\nimport { EMPTY } from './empty';\nimport { popNumber, popScheduler } from '../util/args';\nimport { from } from './from';\nexport function merge(...args) {\n    const scheduler = popScheduler(args);\n    const concurrent = popNumber(args, Infinity);\n    const sources = args;\n    return !sources.length\n        ?\n            EMPTY\n        : sources.length === 1\n            ?\n                innerFrom(sources[0])\n            :\n                mergeAll(concurrent)(from(sources, scheduler));\n}\n","import { popScheduler } from '../util/args';\nimport { from } from './from';\nexport function of(...args) {\n    const scheduler = popScheduler(args);\n    return from(args, scheduler);\n}\n","import { Subscriber } from '../Subscriber';\nexport function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {\n    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\nexport class OperatorSubscriber extends Subscriber {\n    constructor(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {\n        super(destination);\n        this.onFinalize = onFinalize;\n        this.shouldUnsubscribe = shouldUnsubscribe;\n        this._next = onNext\n            ? function (value) {\n                try {\n                    onNext(value);\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n            }\n            : super._next;\n        this._error = onError\n            ? function (err) {\n                try {\n                    onError(err);\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n                finally {\n                    this.unsubscribe();\n                }\n            }\n            : super._error;\n        this._complete = onComplete\n            ? function () {\n                try {\n                    onComplete();\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n                finally {\n                    this.unsubscribe();\n                }\n            }\n            : super._complete;\n    }\n    unsubscribe() {\n        var _a;\n        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n            const { closed } = this;\n            super.unsubscribe();\n            !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));\n        }\n    }\n}\n","import { concat } from '../observable/concat';\nimport { take } from './take';\nimport { ignoreElements } from './ignoreElements';\nimport { mapTo } from './mapTo';\nimport { mergeMap } from './mergeMap';\nexport function delayWhen(delayDurationSelector, subscriptionDelay) {\n    if (subscriptionDelay) {\n        return (source) => concat(subscriptionDelay.pipe(take(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));\n    }\n    return mergeMap((value, index) => delayDurationSelector(value, index).pipe(take(1), mapTo(value)));\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { delayWhen } from './delayWhen';\nimport { timer } from '../observable/timer';\nexport function delay(due, scheduler = asyncScheduler) {\n    const duration = timer(due, scheduler);\n    return delayWhen(() => duration);\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function filter(predicate, thisArg) {\n    return operate((source, subscriber) => {\n        let index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index++) && subscriber.next(value)));\n    });\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\nexport function ignoreElements() {\n    return operate((source, subscriber) => {\n        source.subscribe(createOperatorSubscriber(subscriber, noop));\n    });\n}\n","import { map } from './map';\nexport function mapTo(value) {\n    return map(() => value);\n}\n","import { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nexport function mergeAll(concurrent = Infinity) {\n    return mergeMap(identity, concurrent);\n}\n","import { executeSchedule } from '../util/executeSchedule';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function observeOn(scheduler, delay = 0) {\n    return operate((source, subscriber) => {\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => executeSchedule(subscriber, scheduler, () => subscriber.next(value), delay), () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay), (err) => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)));\n    });\n}\n","import { concat } from '../observable/concat';\nimport { popScheduler } from '../util/args';\nimport { operate } from '../util/lift';\nexport function startWith(...values) {\n    const scheduler = popScheduler(values);\n    return operate((source, subscriber) => {\n        (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);\n    });\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function switchMap(project, resultSelector) {\n    return operate((source, subscriber) => {\n        let innerSubscriber = null;\n        let index = 0;\n        let isComplete = false;\n        const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();\n            let innerIndex = 0;\n            const outerIndex = index++;\n            innerFrom(project(value, outerIndex)).subscribe((innerSubscriber = createOperatorSubscriber(subscriber, (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue), () => {\n                innerSubscriber = null;\n                checkComplete();\n            })));\n        }, () => {\n            isComplete = true;\n            checkComplete();\n        }));\n    });\n}\n","import { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function take(count) {\n    return count <= 0\n        ?\n            () => EMPTY\n        : operate((source, subscriber) => {\n            let seen = 0;\n            source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n                if (++seen <= count) {\n                    subscriber.next(value);\n                    if (count <= seen) {\n                        subscriber.complete();\n                    }\n                }\n            }));\n        });\n}\n","import { isFunction } from '../util/isFunction';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { identity } from '../util/identity';\nexport function tap(observerOrNext, error, complete) {\n    const tapObserver = isFunction(observerOrNext) || error || complete\n        ?\n            { next: observerOrNext, error, complete }\n        : observerOrNext;\n    return tapObserver\n        ? operate((source, subscriber) => {\n            var _a;\n            (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n            let isUnsub = true;\n            source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n                var _a;\n                (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);\n                subscriber.next(value);\n            }, () => {\n                var _a;\n                isUnsub = false;\n                (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n                subscriber.complete();\n            }, (err) => {\n                var _a;\n                isUnsub = false;\n                (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);\n                subscriber.error(err);\n            }, () => {\n                var _a, _b;\n                if (isUnsub) {\n                    (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n                }\n                (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);\n            }));\n        })\n        :\n            identity;\n}\n","import { isFunction } from './isFunction';\nimport { isScheduler } from './isScheduler';\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nexport function popResultSelector(args) {\n    return isFunction(last(args)) ? args.pop() : undefined;\n}\nexport function popScheduler(args) {\n    return isScheduler(last(args)) ? args.pop() : undefined;\n}\nexport function popNumber(args, defaultValue) {\n    return typeof last(args) === 'number' ? args.pop() : defaultValue;\n}\n","import { isFunction } from './isFunction';\nexport function hasLift(source) {\n    return isFunction(source === null || source === void 0 ? void 0 : source.lift);\n}\nexport function operate(init) {\n    return (source) => {\n        if (hasLift(source)) {\n            return source.lift(function (liftedSource) {\n                try {\n                    return init(liftedSource, this);\n                }\n                catch (err) {\n                    this.error(err);\n                }\n            });\n        }\n        throw new TypeError('Unable to lift unknown Observable type');\n    };\n}\n","import { map } from \"../operators/map\";\nconst { isArray } = Array;\nfunction callOrApply(fn, args) {\n    return isArray(args) ? fn(...args) : fn(args);\n}\nexport function mapOneOrManyArgs(fn) {\n    return map(args => callOrApply(fn, args));\n}\n","import * as i0 from '@angular/core';\nimport { InjectionToken, EventEmitter, TemplateRef, Directive, Inject, ViewChild, Input, Output, Component, ViewEncapsulation, ChangeDetectionStrategy, ContentChildren, forwardRef, Optional, Host, NgModule } from '@angular/core';\nimport { mixinDisableRipple, MAT_OPTION_PARENT_COMPONENT, MAT_OPTGROUP, MatOption, MatOptionSelectionChange, _countGroupLabelsBeforeOption, _getOptionScrollPosition, MatOptionModule, MatCommonModule } from '@angular/material/core';\nimport * as i2 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i3 from '@angular/cdk/scrolling';\nimport { CdkScrollableModule } from '@angular/cdk/scrolling';\nimport * as i1$1 from '@angular/cdk/overlay';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty, coerceStringArray } from '@angular/cdk/coercion';\nimport * as i1 from '@angular/cdk/platform';\nimport { _getEventTarget } from '@angular/cdk/platform';\nimport { trigger, state, style, transition, group, animate } from '@angular/animations';\nimport { Subscription, Subject, defer, merge, of, fromEvent } from 'rxjs';\nimport { hasModifierKey, ESCAPE, ENTER, UP_ARROW, DOWN_ARROW, TAB } from '@angular/cdk/keycodes';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport * as i4 from '@angular/material/form-field';\nimport { MAT_FORM_FIELD } from '@angular/material/form-field';\nimport { startWith, switchMap, take, filter, map, tap, delay } from 'rxjs/operators';\nimport * as i2$1 from '@angular/cdk/bidi';\n\n// Animation values come from\n// https://github.com/material-components/material-components-web/blob/master/packages/mdc-menu-surface/_mixins.scss\n// TODO(mmalerba): Ideally find a way to import the values from MDC's code.\nconst panelAnimation = trigger('panelAnimation', [\n    state('void, hidden', style({\n        opacity: 0,\n        transform: 'scaleY(0.8)',\n    })),\n    transition(':enter, hidden => visible', [\n        group([\n            animate('0.03s linear', style({ opacity: 1 })),\n            animate('0.12s cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'scaleY(1)' })),\n        ]),\n    ]),\n    transition(':leave, visible => hidden', [animate('0.075s linear', style({ opacity: 0 }))]),\n]);\n\n/**\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n */\nlet _uniqueAutocompleteIdCounter = 0;\n/** Event object that is emitted when an autocomplete option is selected. */\nclass MatAutocompleteSelectedEvent {\n    constructor(\n    /** Reference to the autocomplete panel that emitted the event. */\n    source, \n    /** Option that was selected. */\n    option) {\n        this.source = source;\n        this.option = option;\n    }\n}\n// Boilerplate for applying mixins to MatAutocomplete.\n/** @docs-private */\nconst _MatAutocompleteMixinBase = mixinDisableRipple(class {\n});\n/** Injection token to be used to override the default options for `mat-autocomplete`. */\nconst MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new InjectionToken('mat-autocomplete-default-options', {\n    providedIn: 'root',\n    factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY,\n});\n/** @docs-private */\nfunction MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {\n    return {\n        autoActiveFirstOption: false,\n        autoSelectActiveOption: false,\n        hideSingleSelectionIndicator: false,\n    };\n}\n/** Base class with all of the `MatAutocomplete` functionality. */\nclass _MatAutocompleteBase extends _MatAutocompleteMixinBase {\n    /** Whether the autocomplete panel is open. */\n    get isOpen() {\n        return this._isOpen && this.showPanel;\n    }\n    /** @docs-private Sets the theme color of the panel. */\n    _setColor(value) {\n        this._color = value;\n        this._setThemeClasses(this._classList);\n    }\n    /**\n     * Whether the first option should be highlighted when the autocomplete panel is opened.\n     * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\n     */\n    get autoActiveFirstOption() {\n        return this._autoActiveFirstOption;\n    }\n    set autoActiveFirstOption(value) {\n        this._autoActiveFirstOption = coerceBooleanProperty(value);\n    }\n    /** Whether the active option should be selected as the user is navigating. */\n    get autoSelectActiveOption() {\n        return this._autoSelectActiveOption;\n    }\n    set autoSelectActiveOption(value) {\n        this._autoSelectActiveOption = coerceBooleanProperty(value);\n    }\n    /**\n     * Takes classes set on the host mat-autocomplete element and applies them to the panel\n     * inside the overlay container to allow for easy styling.\n     */\n    set classList(value) {\n        if (value && value.length) {\n            this._classList = coerceStringArray(value).reduce((classList, className) => {\n                classList[className] = true;\n                return classList;\n            }, {});\n        }\n        else {\n            this._classList = {};\n        }\n        this._setVisibilityClasses(this._classList);\n        this._setThemeClasses(this._classList);\n        this._elementRef.nativeElement.className = '';\n    }\n    constructor(_changeDetectorRef, _elementRef, _defaults, platform) {\n        super();\n        this._changeDetectorRef = _changeDetectorRef;\n        this._elementRef = _elementRef;\n        this._defaults = _defaults;\n        this._activeOptionChanges = Subscription.EMPTY;\n        /** Whether the autocomplete panel should be visible, depending on option length. */\n        this.showPanel = false;\n        this._isOpen = false;\n        /** Function that maps an option's control value to its display value in the trigger. */\n        this.displayWith = null;\n        /** Event that is emitted whenever an option from the list is selected. */\n        this.optionSelected = new EventEmitter();\n        /** Event that is emitted when the autocomplete panel is opened. */\n        this.opened = new EventEmitter();\n        /** Event that is emitted when the autocomplete panel is closed. */\n        this.closed = new EventEmitter();\n        /** Emits whenever an option is activated. */\n        this.optionActivated = new EventEmitter();\n        this._classList = {};\n        /** Unique ID to be used by autocomplete trigger's \"aria-owns\" property. */\n        this.id = `mat-autocomplete-${_uniqueAutocompleteIdCounter++}`;\n        // TODO(crisbeto): the problem that the `inertGroups` option resolves is only present on\n        // Safari using VoiceOver. We should occasionally check back to see whether the bug\n        // wasn't resolved in VoiceOver, and if it has, we can remove this and the `inertGroups`\n        // option altogether.\n        this.inertGroups = platform?.SAFARI || false;\n        this._autoActiveFirstOption = !!_defaults.autoActiveFirstOption;\n        this._autoSelectActiveOption = !!_defaults.autoSelectActiveOption;\n    }\n    ngAfterContentInit() {\n        this._keyManager = new ActiveDescendantKeyManager(this.options)\n            .withWrap()\n            .skipPredicate(this._skipPredicate);\n        this._activeOptionChanges = this._keyManager.change.subscribe(index => {\n            if (this.isOpen) {\n                this.optionActivated.emit({ source: this, option: this.options.toArray()[index] || null });\n            }\n        });\n        // Set the initial visibility state.\n        this._setVisibility();\n    }\n    ngOnDestroy() {\n        this._keyManager?.destroy();\n        this._activeOptionChanges.unsubscribe();\n    }\n    /**\n     * Sets the panel scrollTop. This allows us to manually scroll to display options\n     * above or below the fold, as they are not actually being focused when active.\n     */\n    _setScrollTop(scrollTop) {\n        if (this.panel) {\n            this.panel.nativeElement.scrollTop = scrollTop;\n        }\n    }\n    /** Returns the panel's scrollTop. */\n    _getScrollTop() {\n        return this.panel ? this.panel.nativeElement.scrollTop : 0;\n    }\n    /** Panel should hide itself when the option list is empty. */\n    _setVisibility() {\n        this.showPanel = !!this.options.length;\n        this._setVisibilityClasses(this._classList);\n        this._changeDetectorRef.markForCheck();\n    }\n    /** Emits the `select` event. */\n    _emitSelectEvent(option) {\n        const event = new MatAutocompleteSelectedEvent(this, option);\n        this.optionSelected.emit(event);\n    }\n    /** Gets the aria-labelledby for the autocomplete panel. */\n    _getPanelAriaLabelledby(labelId) {\n        if (this.ariaLabel) {\n            return null;\n        }\n        const labelExpression = labelId ? labelId + ' ' : '';\n        return this.ariaLabelledby ? labelExpression + this.ariaLabelledby : labelId;\n    }\n    /** Sets the autocomplete visibility classes on a classlist based on the panel is visible. */\n    _setVisibilityClasses(classList) {\n        classList[this._visibleClass] = this.showPanel;\n        classList[this._hiddenClass] = !this.showPanel;\n    }\n    /** Sets the theming classes on a classlist based on the theme of the panel. */\n    _setThemeClasses(classList) {\n        classList['mat-primary'] = this._color === 'primary';\n        classList['mat-warn'] = this._color === 'warn';\n        classList['mat-accent'] = this._color === 'accent';\n    }\n    _skipPredicate(option) {\n        return option.disabled;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: _MatAutocompleteBase, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS }, { token: i1.Platform }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.0.0\", type: _MatAutocompleteBase, inputs: { ariaLabel: [\"aria-label\", \"ariaLabel\"], ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"], displayWith: \"displayWith\", autoActiveFirstOption: \"autoActiveFirstOption\", autoSelectActiveOption: \"autoSelectActiveOption\", panelWidth: \"panelWidth\", classList: [\"class\", \"classList\"] }, outputs: { optionSelected: \"optionSelected\", opened: \"opened\", closed: \"closed\", optionActivated: \"optionActivated\" }, viewQueries: [{ propertyName: \"template\", first: true, predicate: TemplateRef, descendants: true, static: true }, { propertyName: \"panel\", first: true, predicate: [\"panel\"], descendants: true }], usesInheritance: true, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: _MatAutocompleteBase, decorators: [{\n            type: Directive\n        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS]\n                }] }, { type: i1.Platform }]; }, propDecorators: { template: [{\n                type: ViewChild,\n                args: [TemplateRef, { static: true }]\n            }], panel: [{\n                type: ViewChild,\n                args: ['panel']\n            }], ariaLabel: [{\n                type: Input,\n                args: ['aria-label']\n            }], ariaLabelledby: [{\n                type: Input,\n                args: ['aria-labelledby']\n            }], displayWith: [{\n                type: Input\n            }], autoActiveFirstOption: [{\n                type: Input\n            }], autoSelectActiveOption: [{\n                type: Input\n            }], panelWidth: [{\n                type: Input\n            }], optionSelected: [{\n                type: Output\n            }], opened: [{\n                type: Output\n            }], closed: [{\n                type: Output\n            }], optionActivated: [{\n                type: Output\n            }], classList: [{\n                type: Input,\n                args: ['class']\n            }] } });\nclass MatAutocomplete extends _MatAutocompleteBase {\n    constructor() {\n        super(...arguments);\n        this._visibleClass = 'mat-mdc-autocomplete-visible';\n        this._hiddenClass = 'mat-mdc-autocomplete-hidden';\n        this._hideSingleSelectionIndicator = this._defaults.hideSingleSelectionIndicator ?? false;\n    }\n    /** Whether checkmark indicator for single-selection options is hidden. */\n    get hideSingleSelectionIndicator() {\n        return this._hideSingleSelectionIndicator;\n    }\n    set hideSingleSelectionIndicator(value) {\n        this._hideSingleSelectionIndicator = coerceBooleanProperty(value);\n        this._syncParentProperties();\n    }\n    /** Syncs the parent state with the individual options. */\n    _syncParentProperties() {\n        if (this.options) {\n            for (const option of this.options) {\n                option._changeDetectorRef.markForCheck();\n            }\n        }\n    }\n    // `skipPredicate` determines if key manager should avoid putting a given option in the tab\n    // order. Allow disabled list items to receive focus via keyboard to align with WAI ARIA\n    // recommendation.\n    //\n    // Normally WAI ARIA's instructions are to exclude disabled items from the tab order, but it\n    // makes a few exceptions for compound widgets.\n    //\n    // From [Developing a Keyboard Interface](\n    // https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/):\n    //   \"For the following composite widget elements, keep them focusable when disabled: Options in a\n    //   Listbox...\"\n    //\n    // The user can focus disabled options using the keyboard, but the user cannot click disabled\n    // options.\n    _skipPredicate(_option) {\n        return false;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: MatAutocomplete, deps: null, target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"16.0.0\", type: MatAutocomplete, selector: \"mat-autocomplete\", inputs: { disableRipple: \"disableRipple\", hideSingleSelectionIndicator: \"hideSingleSelectionIndicator\" }, host: { attributes: { \"ngSkipHydration\": \"\" }, classAttribute: \"mat-mdc-autocomplete\" }, providers: [{ provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatAutocomplete }], queries: [{ propertyName: \"optionGroups\", predicate: MAT_OPTGROUP, descendants: true }, { propertyName: \"options\", predicate: MatOption, descendants: true }], exportAs: [\"matAutocomplete\"], usesInheritance: true, ngImport: i0, template: \"<ng-template let-formFieldId=\\\"id\\\">\\n  <div\\n    class=\\\"mat-mdc-autocomplete-panel mdc-menu-surface mdc-menu-surface--open\\\"\\n    role=\\\"listbox\\\"\\n    [id]=\\\"id\\\"\\n    [ngClass]=\\\"_classList\\\"\\n    [attr.aria-label]=\\\"ariaLabel || null\\\"\\n    [attr.aria-labelledby]=\\\"_getPanelAriaLabelledby(formFieldId)\\\"\\n    [@panelAnimation]=\\\"isOpen ? 'visible' : 'hidden'\\\"\\n    #panel>\\n    <ng-content></ng-content>\\n  </div>\\n</ng-template>\\n\", styles: [\".mdc-menu-surface{display:none;position:absolute;box-sizing:border-box;margin:0;padding:0;transform:scale(1);transform-origin:top left;opacity:0;overflow:auto;will-change:transform,opacity;transform-origin-left:top left;transform-origin-right:top right}.mdc-menu-surface:focus{outline:none}.mdc-menu-surface--animating-open{display:inline-block;transform:scale(0.8);opacity:0}.mdc-menu-surface--open{display:inline-block;transform:scale(1);opacity:1}.mdc-menu-surface--animating-closed{display:inline-block;opacity:0}[dir=rtl] .mdc-menu-surface,.mdc-menu-surface[dir=rtl]{transform-origin-left:top right;transform-origin-right:top left}.mdc-menu-surface--anchor{position:relative;overflow:visible}.mdc-menu-surface--fixed{position:fixed}.mdc-menu-surface--fullwidth{width:100%}.mdc-menu-surface{max-width:calc(100vw - 32px);max-width:var(--mdc-menu-max-width, calc(100vw - 32px));max-height:calc(100vh - 32px);max-height:var(--mdc-menu-max-height, calc(100vh - 32px));z-index:8;border-radius:4px;border-radius:var(--mdc-shape-medium, 4px)}.mdc-menu-surface.mat-mdc-autocomplete-panel{width:100%;max-height:256px;position:static;visibility:hidden;transform-origin:center top;margin:0;padding:8px 0;list-style-type:none}.mdc-menu-surface.mat-mdc-autocomplete-panel:focus{outline:none}.cdk-high-contrast-active .mdc-menu-surface.mat-mdc-autocomplete-panel{outline:solid 1px}.cdk-overlay-pane:not(.mat-mdc-autocomplete-panel-above) .mdc-menu-surface.mat-mdc-autocomplete-panel{border-top-left-radius:0;border-top-right-radius:0}.mat-mdc-autocomplete-panel-above .mdc-menu-surface.mat-mdc-autocomplete-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:center bottom}.mdc-menu-surface.mat-mdc-autocomplete-panel.mat-mdc-autocomplete-visible{visibility:visible}.mdc-menu-surface.mat-mdc-autocomplete-panel.mat-mdc-autocomplete-hidden{visibility:hidden}mat-autocomplete{display:none}\"], dependencies: [{ kind: \"directive\", type: i2.NgClass, selector: \"[ngClass]\", inputs: [\"class\", \"ngClass\"] }], animations: [panelAnimation], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: MatAutocomplete, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-autocomplete', encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, exportAs: 'matAutocomplete', inputs: ['disableRipple'], host: {\n                        'class': 'mat-mdc-autocomplete',\n                        'ngSkipHydration': '',\n                    }, providers: [{ provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatAutocomplete }], animations: [panelAnimation], template: \"<ng-template let-formFieldId=\\\"id\\\">\\n  <div\\n    class=\\\"mat-mdc-autocomplete-panel mdc-menu-surface mdc-menu-surface--open\\\"\\n    role=\\\"listbox\\\"\\n    [id]=\\\"id\\\"\\n    [ngClass]=\\\"_classList\\\"\\n    [attr.aria-label]=\\\"ariaLabel || null\\\"\\n    [attr.aria-labelledby]=\\\"_getPanelAriaLabelledby(formFieldId)\\\"\\n    [@panelAnimation]=\\\"isOpen ? 'visible' : 'hidden'\\\"\\n    #panel>\\n    <ng-content></ng-content>\\n  </div>\\n</ng-template>\\n\", styles: [\".mdc-menu-surface{display:none;position:absolute;box-sizing:border-box;margin:0;padding:0;transform:scale(1);transform-origin:top left;opacity:0;overflow:auto;will-change:transform,opacity;transform-origin-left:top left;transform-origin-right:top right}.mdc-menu-surface:focus{outline:none}.mdc-menu-surface--animating-open{display:inline-block;transform:scale(0.8);opacity:0}.mdc-menu-surface--open{display:inline-block;transform:scale(1);opacity:1}.mdc-menu-surface--animating-closed{display:inline-block;opacity:0}[dir=rtl] .mdc-menu-surface,.mdc-menu-surface[dir=rtl]{transform-origin-left:top right;transform-origin-right:top left}.mdc-menu-surface--anchor{position:relative;overflow:visible}.mdc-menu-surface--fixed{position:fixed}.mdc-menu-surface--fullwidth{width:100%}.mdc-menu-surface{max-width:calc(100vw - 32px);max-width:var(--mdc-menu-max-width, calc(100vw - 32px));max-height:calc(100vh - 32px);max-height:var(--mdc-menu-max-height, calc(100vh - 32px));z-index:8;border-radius:4px;border-radius:var(--mdc-shape-medium, 4px)}.mdc-menu-surface.mat-mdc-autocomplete-panel{width:100%;max-height:256px;position:static;visibility:hidden;transform-origin:center top;margin:0;padding:8px 0;list-style-type:none}.mdc-menu-surface.mat-mdc-autocomplete-panel:focus{outline:none}.cdk-high-contrast-active .mdc-menu-surface.mat-mdc-autocomplete-panel{outline:solid 1px}.cdk-overlay-pane:not(.mat-mdc-autocomplete-panel-above) .mdc-menu-surface.mat-mdc-autocomplete-panel{border-top-left-radius:0;border-top-right-radius:0}.mat-mdc-autocomplete-panel-above .mdc-menu-surface.mat-mdc-autocomplete-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:center bottom}.mdc-menu-surface.mat-mdc-autocomplete-panel.mat-mdc-autocomplete-visible{visibility:visible}.mdc-menu-surface.mat-mdc-autocomplete-panel.mat-mdc-autocomplete-hidden{visibility:hidden}mat-autocomplete{display:none}\"] }]\n        }], propDecorators: { optionGroups: [{\n                type: ContentChildren,\n                args: [MAT_OPTGROUP, { descendants: true }]\n            }], options: [{\n                type: ContentChildren,\n                args: [MatOption, { descendants: true }]\n            }], hideSingleSelectionIndicator: [{\n                type: Input\n            }] } });\n\n/** Base class containing all of the functionality for `MatAutocompleteOrigin`. */\nclass _MatAutocompleteOriginBase {\n    constructor(\n    /** Reference to the element on which the directive is applied. */\n    elementRef) {\n        this.elementRef = elementRef;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: _MatAutocompleteOriginBase, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.0.0\", type: _MatAutocompleteOriginBase, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: _MatAutocompleteOriginBase, decorators: [{\n            type: Directive\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });\n/**\n * Directive applied to an element to make it usable\n * as a connection point for an autocomplete panel.\n */\nclass MatAutocompleteOrigin extends _MatAutocompleteOriginBase {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: MatAutocompleteOrigin, deps: null, target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.0.0\", type: MatAutocompleteOrigin, selector: \"[matAutocompleteOrigin]\", exportAs: [\"matAutocompleteOrigin\"], usesInheritance: true, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: MatAutocompleteOrigin, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[matAutocompleteOrigin]',\n                    exportAs: 'matAutocompleteOrigin',\n                }]\n        }] });\n\n/**\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * @docs-private\n */\nconst MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => MatAutocompleteTrigger),\n    multi: true,\n};\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n * @docs-private\n */\nfunction getMatAutocompleteMissingPanelError() {\n    return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' +\n        'Make sure that the id passed to the `matAutocomplete` is correct and that ' +\n        \"you're attempting to open it after the ngAfterContentInit hook.\");\n}\n/** Injection token that determines the scroll handling while the autocomplete panel is open. */\nconst MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new InjectionToken('mat-autocomplete-scroll-strategy');\n/** @docs-private */\nfunction MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay) {\n    return () => overlay.scrollStrategies.reposition();\n}\n/** @docs-private */\nconst MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY,\n};\n/** Base class with all of the `MatAutocompleteTrigger` functionality. */\nclass _MatAutocompleteTriggerBase {\n    /**\n     * Whether the autocomplete is disabled. When disabled, the element will\n     * act as a regular input and the user won't be able to open the panel.\n     */\n    get autocompleteDisabled() {\n        return this._autocompleteDisabled;\n    }\n    set autocompleteDisabled(value) {\n        this._autocompleteDisabled = coerceBooleanProperty(value);\n    }\n    constructor(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, _viewportRuler, _defaults) {\n        this._element = _element;\n        this._overlay = _overlay;\n        this._viewContainerRef = _viewContainerRef;\n        this._zone = _zone;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._dir = _dir;\n        this._formField = _formField;\n        this._document = _document;\n        this._viewportRuler = _viewportRuler;\n        this._defaults = _defaults;\n        this._componentDestroyed = false;\n        this._autocompleteDisabled = false;\n        /** Whether or not the label state is being overridden. */\n        this._manuallyFloatingLabel = false;\n        /** Subscription to viewport size changes. */\n        this._viewportSubscription = Subscription.EMPTY;\n        /**\n         * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n         * closed autocomplete from being reopened if the user switches to another browser tab and then\n         * comes back.\n         */\n        this._canOpenOnNextFocus = true;\n        /** Stream of keyboard events that can close the panel. */\n        this._closeKeyEventStream = new Subject();\n        /**\n         * Event handler for when the window is blurred. Needs to be an\n         * arrow function in order to preserve the context.\n         */\n        this._windowBlurHandler = () => {\n            // If the user blurred the window while the autocomplete is focused, it means that it'll be\n            // refocused when they come back. In this case we want to skip the first focus event, if the\n            // pane was closed, in order to avoid reopening it unintentionally.\n            this._canOpenOnNextFocus =\n                this._document.activeElement !== this._element.nativeElement || this.panelOpen;\n        };\n        /** `View -> model callback called when value changes` */\n        this._onChange = () => { };\n        /** `View -> model callback called when autocomplete has been touched` */\n        this._onTouched = () => { };\n        /**\n         * Position of the autocomplete panel relative to the trigger element. A position of `auto`\n         * will render the panel underneath the trigger if there is enough space for it to fit in\n         * the viewport, otherwise the panel will be shown above it. If the position is set to\n         * `above` or `below`, the panel will always be shown above or below the trigger. no matter\n         * whether it fits completely in the viewport.\n         */\n        this.position = 'auto';\n        /**\n         * `autocomplete` attribute to be set on the input element.\n         * @docs-private\n         */\n        this.autocompleteAttribute = 'off';\n        this._overlayAttached = false;\n        /** Stream of changes to the selection state of the autocomplete options. */\n        this.optionSelections = defer(() => {\n            const options = this.autocomplete ? this.autocomplete.options : null;\n            if (options) {\n                return options.changes.pipe(startWith(options), switchMap(() => merge(...options.map(option => option.onSelectionChange))));\n            }\n            // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n            // Return a stream that we'll replace with the real one once everything is in place.\n            return this._zone.onStable.pipe(take(1), switchMap(() => this.optionSelections));\n        });\n        this._scrollStrategy = scrollStrategy;\n    }\n    ngAfterViewInit() {\n        const window = this._getWindow();\n        if (typeof window !== 'undefined') {\n            this._zone.runOutsideAngular(() => window.addEventListener('blur', this._windowBlurHandler));\n        }\n    }\n    ngOnChanges(changes) {\n        if (changes['position'] && this._positionStrategy) {\n            this._setStrategyPositions(this._positionStrategy);\n            if (this.panelOpen) {\n                this._overlayRef.updatePosition();\n            }\n        }\n    }\n    ngOnDestroy() {\n        const window = this._getWindow();\n        if (typeof window !== 'undefined') {\n            window.removeEventListener('blur', this._windowBlurHandler);\n        }\n        this._viewportSubscription.unsubscribe();\n        this._componentDestroyed = true;\n        this._destroyPanel();\n        this._closeKeyEventStream.complete();\n    }\n    /** Whether or not the autocomplete panel is open. */\n    get panelOpen() {\n        return this._overlayAttached && this.autocomplete.showPanel;\n    }\n    /** Opens the autocomplete suggestion panel. */\n    openPanel() {\n        this._attachOverlay();\n        this._floatLabel();\n    }\n    /** Closes the autocomplete suggestion panel. */\n    closePanel() {\n        this._resetLabel();\n        if (!this._overlayAttached) {\n            return;\n        }\n        if (this.panelOpen) {\n            // Only emit if the panel was visible.\n            // The `NgZone.onStable` always emits outside of the Angular zone,\n            // so all the subscriptions from `_subscribeToClosingActions()` are also outside of the Angular zone.\n            // We should manually run in Angular zone to update UI after panel closing.\n            this._zone.run(() => {\n                this.autocomplete.closed.emit();\n            });\n        }\n        this.autocomplete._isOpen = this._overlayAttached = false;\n        this._pendingAutoselectedOption = null;\n        if (this._overlayRef && this._overlayRef.hasAttached()) {\n            this._overlayRef.detach();\n            this._closingActionsSubscription.unsubscribe();\n        }\n        // Note that in some cases this can end up being called after the component is destroyed.\n        // Add a check to ensure that we don't try to run change detection on a destroyed view.\n        if (!this._componentDestroyed) {\n            // We need to trigger change detection manually, because\n            // `fromEvent` doesn't seem to do it at the proper time.\n            // This ensures that the label is reset when the\n            // user clicks outside.\n            this._changeDetectorRef.detectChanges();\n        }\n    }\n    /**\n     * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n     * within the viewport.\n     */\n    updatePosition() {\n        if (this._overlayAttached) {\n            this._overlayRef.updatePosition();\n        }\n    }\n    /**\n     * A stream of actions that should close the autocomplete panel, including\n     * when an option is selected, on blur, and when TAB is pressed.\n     */\n    get panelClosingActions() {\n        return merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(filter(() => this._overlayAttached)), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef\n            ? this._overlayRef.detachments().pipe(filter(() => this._overlayAttached))\n            : of()).pipe(\n        // Normalize the output so we return a consistent type.\n        map(event => (event instanceof MatOptionSelectionChange ? event : null)));\n    }\n    /** The currently active option, coerced to MatOption type. */\n    get activeOption() {\n        if (this.autocomplete && this.autocomplete._keyManager) {\n            return this.autocomplete._keyManager.activeItem;\n        }\n        return null;\n    }\n    /** Stream of clicks outside of the autocomplete panel. */\n    _getOutsideClickStream() {\n        return merge(fromEvent(this._document, 'click'), fromEvent(this._document, 'auxclick'), fromEvent(this._document, 'touchend')).pipe(filter(event => {\n            // If we're in the Shadow DOM, the event target will be the shadow root, so we have to\n            // fall back to check the first element in the path of the click event.\n            const clickTarget = _getEventTarget(event);\n            const formField = this._formField ? this._formField._elementRef.nativeElement : null;\n            const customOrigin = this.connectedTo ? this.connectedTo.elementRef.nativeElement : null;\n            return (this._overlayAttached &&\n                clickTarget !== this._element.nativeElement &&\n                // Normally focus moves inside `mousedown` so this condition will almost always be\n                // true. Its main purpose is to handle the case where the input is focused from an\n                // outside click which propagates up to the `body` listener within the same sequence\n                // and causes the panel to close immediately (see #3106).\n                this._document.activeElement !== this._element.nativeElement &&\n                (!formField || !formField.contains(clickTarget)) &&\n                (!customOrigin || !customOrigin.contains(clickTarget)) &&\n                !!this._overlayRef &&\n                !this._overlayRef.overlayElement.contains(clickTarget));\n        }));\n    }\n    // Implemented as part of ControlValueAccessor.\n    writeValue(value) {\n        Promise.resolve(null).then(() => this._assignOptionValue(value));\n    }\n    // Implemented as part of ControlValueAccessor.\n    registerOnChange(fn) {\n        this._onChange = fn;\n    }\n    // Implemented as part of ControlValueAccessor.\n    registerOnTouched(fn) {\n        this._onTouched = fn;\n    }\n    // Implemented as part of ControlValueAccessor.\n    setDisabledState(isDisabled) {\n        this._element.nativeElement.disabled = isDisabled;\n    }\n    _handleKeydown(event) {\n        const keyCode = event.keyCode;\n        const hasModifier = hasModifierKey(event);\n        // Prevent the default action on all escape key presses. This is here primarily to bring IE\n        // in line with other browsers. By default, pressing escape on IE will cause it to revert\n        // the input value to the one that it had on focus, however it won't dispatch any events\n        // which means that the model value will be out of sync with the view.\n        if (keyCode === ESCAPE && !hasModifier) {\n            event.preventDefault();\n        }\n        if (this.activeOption && keyCode === ENTER && this.panelOpen && !hasModifier) {\n            this.activeOption._selectViaInteraction();\n            this._resetActiveItem();\n            event.preventDefault();\n        }\n        else if (this.autocomplete) {\n            const prevActiveItem = this.autocomplete._keyManager.activeItem;\n            const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\n            if (keyCode === TAB || (isArrowKey && !hasModifier && this.panelOpen)) {\n                this.autocomplete._keyManager.onKeydown(event);\n            }\n            else if (isArrowKey && this._canOpen()) {\n                this.openPanel();\n            }\n            if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {\n                this._scrollToOption(this.autocomplete._keyManager.activeItemIndex || 0);\n                if (this.autocomplete.autoSelectActiveOption && this.activeOption) {\n                    if (!this._pendingAutoselectedOption) {\n                        this._valueBeforeAutoSelection = this._element.nativeElement.value;\n                    }\n                    this._pendingAutoselectedOption = this.activeOption;\n                    this._assignOptionValue(this.activeOption.value);\n                }\n            }\n        }\n    }\n    _handleInput(event) {\n        let target = event.target;\n        let value = target.value;\n        // Based on `NumberValueAccessor` from forms.\n        if (target.type === 'number') {\n            value = value == '' ? null : parseFloat(value);\n        }\n        // If the input has a placeholder, IE will fire the `input` event on page load,\n        // focus and blur, in addition to when the user actually changed the value. To\n        // filter out all of the extra events, we save the value on focus and between\n        // `input` events, and we check whether it changed.\n        // See: https://connect.microsoft.com/IE/feedback/details/885747/\n        if (this._previousValue !== value) {\n            this._previousValue = value;\n            this._pendingAutoselectedOption = null;\n            this._onChange(value);\n            if (this._canOpen() && this._document.activeElement === event.target) {\n                this.openPanel();\n            }\n        }\n    }\n    _handleFocus() {\n        if (!this._canOpenOnNextFocus) {\n            this._canOpenOnNextFocus = true;\n        }\n        else if (this._canOpen()) {\n            this._previousValue = this._element.nativeElement.value;\n            this._attachOverlay();\n            this._floatLabel(true);\n        }\n    }\n    _handleClick() {\n        if (this._canOpen() && !this.panelOpen) {\n            this.openPanel();\n        }\n    }\n    /**\n     * In \"auto\" mode, the label will animate down as soon as focus is lost.\n     * This causes the value to jump when selecting an option with the mouse.\n     * This method manually floats the label until the panel can be closed.\n     * @param shouldAnimate Whether the label should be animated when it is floated.\n     */\n    _floatLabel(shouldAnimate = false) {\n        if (this._formField && this._formField.floatLabel === 'auto') {\n            if (shouldAnimate) {\n                this._formField._animateAndLockLabel();\n            }\n            else {\n                this._formField.floatLabel = 'always';\n            }\n            this._manuallyFloatingLabel = true;\n        }\n    }\n    /** If the label has been manually elevated, return it to its normal state. */\n    _resetLabel() {\n        if (this._manuallyFloatingLabel) {\n            if (this._formField) {\n                this._formField.floatLabel = 'auto';\n            }\n            this._manuallyFloatingLabel = false;\n        }\n    }\n    /**\n     * This method listens to a stream of panel closing actions and resets the\n     * stream every time the option list changes.\n     */\n    _subscribeToClosingActions() {\n        const firstStable = this._zone.onStable.pipe(take(1));\n        const optionChanges = this.autocomplete.options.changes.pipe(tap(() => this._positionStrategy.reapplyLastPosition()), \n        // Defer emitting to the stream until the next tick, because changing\n        // bindings in here will cause \"changed after checked\" errors.\n        delay(0));\n        // When the zone is stable initially, and when the option list changes...\n        return (merge(firstStable, optionChanges)\n            .pipe(\n        // create a new stream of panelClosingActions, replacing any previous streams\n        // that were created, and flatten it so our stream only emits closing events...\n        switchMap(() => {\n            // The `NgZone.onStable` always emits outside of the Angular zone, thus we have to re-enter\n            // the Angular zone. This will lead to change detection being called outside of the Angular\n            // zone and the `autocomplete.opened` will also emit outside of the Angular.\n            this._zone.run(() => {\n                const wasOpen = this.panelOpen;\n                this._resetActiveItem();\n                this.autocomplete._setVisibility();\n                this._changeDetectorRef.detectChanges();\n                if (this.panelOpen) {\n                    this._overlayRef.updatePosition();\n                }\n                if (wasOpen !== this.panelOpen) {\n                    // If the `panelOpen` state changed, we need to make sure to emit the `opened` or\n                    // `closed` event, because we may not have emitted it. This can happen\n                    // - if the users opens the panel and there are no options, but the\n                    //   options come in slightly later or as a result of the value changing,\n                    // - if the panel is closed after the user entered a string that did not match any\n                    //   of the available options,\n                    // - if a valid string is entered after an invalid one.\n                    if (this.panelOpen) {\n                        this.autocomplete.opened.emit();\n                    }\n                    else {\n                        this.autocomplete.closed.emit();\n                    }\n                }\n            });\n            return this.panelClosingActions;\n        }), \n        // when the first closing event occurs...\n        take(1))\n            // set the value, close the panel, and complete.\n            .subscribe(event => this._setValueAndClose(event)));\n    }\n    /** Destroys the autocomplete suggestion panel. */\n    _destroyPanel() {\n        if (this._overlayRef) {\n            this.closePanel();\n            this._overlayRef.dispose();\n            this._overlayRef = null;\n        }\n    }\n    _assignOptionValue(value) {\n        const toDisplay = this.autocomplete && this.autocomplete.displayWith\n            ? this.autocomplete.displayWith(value)\n            : value;\n        // Simply falling back to an empty string if the display value is falsy does not work properly.\n        // The display value can also be the number zero and shouldn't fall back to an empty string.\n        this._updateNativeInputValue(toDisplay != null ? toDisplay : '');\n    }\n    _updateNativeInputValue(value) {\n        // If it's used within a `MatFormField`, we should set it through the property so it can go\n        // through change detection.\n        if (this._formField) {\n            this._formField._control.value = value;\n        }\n        else {\n            this._element.nativeElement.value = value;\n        }\n        this._previousValue = value;\n    }\n    /**\n     * This method closes the panel, and if a value is specified, also sets the associated\n     * control to that value. It will also mark the control as dirty if this interaction\n     * stemmed from the user.\n     */\n    _setValueAndClose(event) {\n        const toSelect = event ? event.source : this._pendingAutoselectedOption;\n        if (toSelect) {\n            this._clearPreviousSelectedOption(toSelect);\n            this._assignOptionValue(toSelect.value);\n            this._onChange(toSelect.value);\n            this.autocomplete._emitSelectEvent(toSelect);\n            this._element.nativeElement.focus();\n        }\n        this.closePanel();\n    }\n    /**\n     * Clear any previous selected option and emit a selection change event for this option\n     */\n    _clearPreviousSelectedOption(skip) {\n        this.autocomplete.options.forEach(option => {\n            if (option !== skip && option.selected) {\n                option.deselect();\n            }\n        });\n    }\n    _attachOverlay() {\n        if (!this.autocomplete && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMatAutocompleteMissingPanelError();\n        }\n        let overlayRef = this._overlayRef;\n        if (!overlayRef) {\n            this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef, {\n                id: this._formField?.getLabelId(),\n            });\n            overlayRef = this._overlay.create(this._getOverlayConfig());\n            this._overlayRef = overlayRef;\n            this._handleOverlayEvents(overlayRef);\n            this._viewportSubscription = this._viewportRuler.change().subscribe(() => {\n                if (this.panelOpen && overlayRef) {\n                    overlayRef.updateSize({ width: this._getPanelWidth() });\n                }\n            });\n        }\n        else {\n            // Update the trigger, panel width and direction, in case anything has changed.\n            this._positionStrategy.setOrigin(this._getConnectedElement());\n            overlayRef.updateSize({ width: this._getPanelWidth() });\n        }\n        if (overlayRef && !overlayRef.hasAttached()) {\n            overlayRef.attach(this._portal);\n            this._closingActionsSubscription = this._subscribeToClosingActions();\n        }\n        const wasOpen = this.panelOpen;\n        this.autocomplete._setVisibility();\n        this.autocomplete._isOpen = this._overlayAttached = true;\n        this.autocomplete._setColor(this._formField?.color);\n        // We need to do an extra `panelOpen` check in here, because the\n        // autocomplete won't be shown if there are no options.\n        if (this.panelOpen && wasOpen !== this.panelOpen) {\n            this.autocomplete.opened.emit();\n        }\n    }\n    _getOverlayConfig() {\n        return new OverlayConfig({\n            positionStrategy: this._getOverlayPosition(),\n            scrollStrategy: this._scrollStrategy(),\n            width: this._getPanelWidth(),\n            direction: this._dir ?? undefined,\n            panelClass: this._defaults?.overlayPanelClass,\n        });\n    }\n    _getOverlayPosition() {\n        const strategy = this._overlay\n            .position()\n            .flexibleConnectedTo(this._getConnectedElement())\n            .withFlexibleDimensions(false)\n            .withPush(false);\n        this._setStrategyPositions(strategy);\n        this._positionStrategy = strategy;\n        return strategy;\n    }\n    /** Sets the positions on a position strategy based on the directive's input state. */\n    _setStrategyPositions(positionStrategy) {\n        // Note that we provide horizontal fallback positions, even though by default the dropdown\n        // width matches the input, because consumers can override the width. See #18854.\n        const belowPositions = [\n            { originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top' },\n            { originX: 'end', originY: 'bottom', overlayX: 'end', overlayY: 'top' },\n        ];\n        // The overlay edge connected to the trigger should have squared corners, while\n        // the opposite end has rounded corners. We apply a CSS class to swap the\n        // border-radius based on the overlay position.\n        const panelClass = this._aboveClass;\n        const abovePositions = [\n            { originX: 'start', originY: 'top', overlayX: 'start', overlayY: 'bottom', panelClass },\n            { originX: 'end', originY: 'top', overlayX: 'end', overlayY: 'bottom', panelClass },\n        ];\n        let positions;\n        if (this.position === 'above') {\n            positions = abovePositions;\n        }\n        else if (this.position === 'below') {\n            positions = belowPositions;\n        }\n        else {\n            positions = [...belowPositions, ...abovePositions];\n        }\n        positionStrategy.withPositions(positions);\n    }\n    _getConnectedElement() {\n        if (this.connectedTo) {\n            return this.connectedTo.elementRef;\n        }\n        return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;\n    }\n    _getPanelWidth() {\n        return this.autocomplete.panelWidth || this._getHostWidth();\n    }\n    /** Returns the width of the input element, so the panel width can match it. */\n    _getHostWidth() {\n        return this._getConnectedElement().nativeElement.getBoundingClientRect().width;\n    }\n    /**\n     * Reset the active item to -1. This is so that pressing arrow keys will activate the correct\n     * option.\n     *\n     * If the consumer opted-in to automatically activatating the first option, activate the first\n     * *enabled* option.\n     */\n    _resetActiveItem() {\n        const autocomplete = this.autocomplete;\n        if (autocomplete.autoActiveFirstOption) {\n            // Find the index of the first *enabled* option. Avoid calling `_keyManager.setActiveItem`\n            // because it activates the first option that passes the skip predicate, rather than the\n            // first *enabled* option.\n            let firstEnabledOptionIndex = -1;\n            for (let index = 0; index < autocomplete.options.length; index++) {\n                const option = autocomplete.options.get(index);\n                if (!option.disabled) {\n                    firstEnabledOptionIndex = index;\n                    break;\n                }\n            }\n            autocomplete._keyManager.setActiveItem(firstEnabledOptionIndex);\n        }\n        else {\n            autocomplete._keyManager.setActiveItem(-1);\n        }\n    }\n    /** Determines whether the panel can be opened. */\n    _canOpen() {\n        const element = this._element.nativeElement;\n        return !element.readOnly && !element.disabled && !this._autocompleteDisabled;\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    _getWindow() {\n        return this._document?.defaultView || window;\n    }\n    /** Scrolls to a particular option in the list. */\n    _scrollToOption(index) {\n        // Given that we are not actually focusing active options, we must manually adjust scroll\n        // to reveal options below the fold. First, we find the offset of the option from the top\n        // of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n        // the panel height + the option height, so the active option will be just visible at the\n        // bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n        // will become the offset. If that offset is visible within the panel already, the scrollTop is\n        // not adjusted.\n        const autocomplete = this.autocomplete;\n        const labelCount = _countGroupLabelsBeforeOption(index, autocomplete.options, autocomplete.optionGroups);\n        if (index === 0 && labelCount === 1) {\n            // If we've got one group label before the option and we're at the top option,\n            // scroll the list to the top. This is better UX than scrolling the list to the\n            // top of the option, because it allows the user to read the top group's label.\n            autocomplete._setScrollTop(0);\n        }\n        else if (autocomplete.panel) {\n            const option = autocomplete.options.toArray()[index];\n            if (option) {\n                const element = option._getHostElement();\n                const newScrollPosition = _getOptionScrollPosition(element.offsetTop, element.offsetHeight, autocomplete._getScrollTop(), autocomplete.panel.nativeElement.offsetHeight);\n                autocomplete._setScrollTop(newScrollPosition);\n            }\n        }\n    }\n    /** Handles keyboard events coming from the overlay panel. */\n    _handleOverlayEvents(overlayRef) {\n        // Use the `keydownEvents` in order to take advantage of\n        // the overlay event targeting provided by the CDK overlay.\n        overlayRef.keydownEvents().subscribe(event => {\n            // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n            // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n            if ((event.keyCode === ESCAPE && !hasModifierKey(event)) ||\n                (event.keyCode === UP_ARROW && hasModifierKey(event, 'altKey'))) {\n                // If the user had typed something in before we autoselected an option, and they decided\n                // to cancel the selection, restore the input value to the one they had typed in.\n                if (this._pendingAutoselectedOption) {\n                    this._updateNativeInputValue(this._valueBeforeAutoSelection ?? '');\n                    this._pendingAutoselectedOption = null;\n                }\n                this._closeKeyEventStream.next();\n                this._resetActiveItem();\n                // We need to stop propagation, otherwise the event will eventually\n                // reach the input itself and cause the overlay to be reopened.\n                event.stopPropagation();\n                event.preventDefault();\n            }\n        });\n        // Subscribe to the pointer events stream so that it doesn't get picked up by other overlays.\n        // TODO(crisbeto): we should switch `_getOutsideClickStream` eventually to use this stream,\n        // but the behvior isn't exactly the same and it ends up breaking some internal tests.\n        overlayRef.outsidePointerEvents().subscribe();\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: _MatAutocompleteTriggerBase, deps: [{ token: i0.ElementRef }, { token: i1$1.Overlay }, { token: i0.ViewContainerRef }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }, { token: MAT_AUTOCOMPLETE_SCROLL_STRATEGY }, { token: i2$1.Directionality, optional: true }, { token: MAT_FORM_FIELD, host: true, optional: true }, { token: DOCUMENT, optional: true }, { token: i3.ViewportRuler }, { token: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, optional: true }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.0.0\", type: _MatAutocompleteTriggerBase, inputs: { autocomplete: [\"matAutocomplete\", \"autocomplete\"], position: [\"matAutocompletePosition\", \"position\"], connectedTo: [\"matAutocompleteConnectedTo\", \"connectedTo\"], autocompleteAttribute: [\"autocomplete\", \"autocompleteAttribute\"], autocompleteDisabled: [\"matAutocompleteDisabled\", \"autocompleteDisabled\"] }, usesOnChanges: true, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: _MatAutocompleteTriggerBase, decorators: [{\n            type: Directive\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1$1.Overlay }, { type: i0.ViewContainerRef }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY]\n                }] }, { type: i2$1.Directionality, decorators: [{\n                    type: Optional\n                }] }, { type: i4.MatFormField, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [MAT_FORM_FIELD]\n                }, {\n                    type: Host\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: i3.ViewportRuler }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS]\n                }] }]; }, propDecorators: { autocomplete: [{\n                type: Input,\n                args: ['matAutocomplete']\n            }], position: [{\n                type: Input,\n                args: ['matAutocompletePosition']\n            }], connectedTo: [{\n                type: Input,\n                args: ['matAutocompleteConnectedTo']\n            }], autocompleteAttribute: [{\n                type: Input,\n                args: ['autocomplete']\n            }], autocompleteDisabled: [{\n                type: Input,\n                args: ['matAutocompleteDisabled']\n            }] } });\nclass MatAutocompleteTrigger extends _MatAutocompleteTriggerBase {\n    constructor() {\n        super(...arguments);\n        this._aboveClass = 'mat-mdc-autocomplete-panel-above';\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: MatAutocompleteTrigger, deps: null, target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.0.0\", type: MatAutocompleteTrigger, selector: \"input[matAutocomplete], textarea[matAutocomplete]\", host: { listeners: { \"focusin\": \"_handleFocus()\", \"blur\": \"_onTouched()\", \"input\": \"_handleInput($event)\", \"keydown\": \"_handleKeydown($event)\", \"click\": \"_handleClick()\" }, properties: { \"attr.autocomplete\": \"autocompleteAttribute\", \"attr.role\": \"autocompleteDisabled ? null : \\\"combobox\\\"\", \"attr.aria-autocomplete\": \"autocompleteDisabled ? null : \\\"list\\\"\", \"attr.aria-activedescendant\": \"(panelOpen && activeOption) ? activeOption.id : null\", \"attr.aria-expanded\": \"autocompleteDisabled ? null : panelOpen.toString()\", \"attr.aria-owns\": \"(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id\", \"attr.aria-haspopup\": \"autocompleteDisabled ? null : \\\"listbox\\\"\" }, classAttribute: \"mat-mdc-autocomplete-trigger\" }, providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR], exportAs: [\"matAutocompleteTrigger\"], usesInheritance: true, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: MatAutocompleteTrigger, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: `input[matAutocomplete], textarea[matAutocomplete]`,\n                    host: {\n                        'class': 'mat-mdc-autocomplete-trigger',\n                        '[attr.autocomplete]': 'autocompleteAttribute',\n                        '[attr.role]': 'autocompleteDisabled ? null : \"combobox\"',\n                        '[attr.aria-autocomplete]': 'autocompleteDisabled ? null : \"list\"',\n                        '[attr.aria-activedescendant]': '(panelOpen && activeOption) ? activeOption.id : null',\n                        '[attr.aria-expanded]': 'autocompleteDisabled ? null : panelOpen.toString()',\n                        '[attr.aria-owns]': '(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id',\n                        '[attr.aria-haspopup]': 'autocompleteDisabled ? null : \"listbox\"',\n                        // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\n                        // a little earlier. This avoids issues where IE delays the focusing of the input.\n                        '(focusin)': '_handleFocus()',\n                        '(blur)': '_onTouched()',\n                        '(input)': '_handleInput($event)',\n                        '(keydown)': '_handleKeydown($event)',\n                        '(click)': '_handleClick()',\n                    },\n                    exportAs: 'matAutocompleteTrigger',\n                    providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR],\n                }]\n        }] });\n\nclass MatAutocompleteModule {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: MatAutocompleteModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"16.0.0\", ngImport: i0, type: MatAutocompleteModule, declarations: [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin], imports: [OverlayModule, MatOptionModule, MatCommonModule, CommonModule], exports: [CdkScrollableModule,\n            MatAutocomplete,\n            MatOptionModule,\n            MatCommonModule,\n            MatAutocompleteTrigger,\n            MatAutocompleteOrigin] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: MatAutocompleteModule, providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER], imports: [OverlayModule, MatOptionModule, MatCommonModule, CommonModule, CdkScrollableModule,\n            MatOptionModule,\n            MatCommonModule] }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: MatAutocompleteModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [OverlayModule, MatOptionModule, MatCommonModule, CommonModule],\n                    exports: [\n                        CdkScrollableModule,\n                        MatAutocomplete,\n                        MatOptionModule,\n                        MatCommonModule,\n                        MatAutocompleteTrigger,\n                        MatAutocompleteOrigin,\n                    ],\n                    declarations: [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin],\n                    providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER, MAT_AUTOCOMPLETE_VALUE_ACCESSOR, MatAutocomplete, MatAutocompleteModule, MatAutocompleteOrigin, MatAutocompleteSelectedEvent, MatAutocompleteTrigger, _MatAutocompleteBase, _MatAutocompleteOriginBase, _MatAutocompleteTriggerBase, getMatAutocompleteMissingPanelError };\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import superPropBase from \"./superPropBase.js\";\nexport default function _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get.bind();\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get.apply(this, arguments);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nexport default function _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40]}